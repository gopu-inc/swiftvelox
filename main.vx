# Am√©liorer le compilateur
cat > SwiftVelox/src/main.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <math.h>

#define MAX_TOKENS 5000
#define MAX_SYMBOLS 100
#define BUFFER_SIZE 1024

// === Structures ===
typedef struct {
    int type;
    char lexeme[256];
    int line;
    int col;
    int int_val;
    double float_val;
} Token;

typedef struct {
    char name[256];
    char type[256];
    char value[256];
} Variable;

// === Prototypes ===
Token* tokenize(const char* source);
void generate_c_code(Token* tokens, const char* output_filename, Variable* vars, int* var_count);
int compile_file(const char* input_file, const char* output_file);

// === RUNTIME ===
void sv_print(const char* msg) {
    printf("%s\n", msg);
}

void sv_print_int(int n) {
    printf("%d\n", n);
}

void sv_print_float(double f) {
    printf("%f\n", f);
}

// === LEXER AM√âLIOR√â ===
typedef enum {
    TK_FN, TK_LET, TK_IF, TK_ELSE, TK_RETURN,
    TK_IMPORT, TK_FOR, TK_WHILE, TK_TRUE, TK_FALSE,
    TK_I32, TK_I64, TK_F32, TK_F64, TK_STRING, TK_BOOL, TK_VOID,
    TK_IDENT, TK_INTLIT, TK_FLOATLIT, TK_STRLIT,
    TK_PLUS, TK_MINUS, TK_MULT, TK_DIV, TK_MOD,
    TK_EQ, TK_NEQ, TK_LT, TK_GT, TK_LE, TK_GE,
    TK_AND, TK_OR, TK_NOT, TK_ASSIGN, TK_ARROW,
    TK_LPAREN, TK_RPAREN, TK_LBRACE, TK_RBRACE,
    TK_LBRACKET, TK_RBRACKET, TK_COMMA, TK_COLON,
    TK_SEMICOLON, TK_DOT, TK_EOF, TK_ERROR
} TokenType;

Token* tokenize(const char* source) {
    static Token tokens[MAX_TOKENS];
    int token_count = 0;
    int i = 0, line = 1, col = 1;
    int len = strlen(source);
    
    while (i < len && token_count < MAX_TOKENS - 1) {
        char ch = source[i];
        
        if (isspace(ch)) {
            if (ch == '\n') { line++; col = 1; }
            i++; col++;
            continue;
        }
        
        if (ch == '/' && i + 1 < len && source[i + 1] == '/') {
            while (i < len && source[i] != '\n') {
                i++; col++;
            }
            continue;
        }
        
        Token* tok = &tokens[token_count];
        tok->line = line;
        tok->col = col;
        
        // Identifiants
        if (isalpha(ch) || ch == '_') {
            int j = 0;
            while (i < len && (isalnum(source[i]) || source[i] == '_')) {
                if (j < 255) tok->lexeme[j++] = source[i];
                i++; col++;
            }
            tok->lexeme[j] = '\0';
            
            if (strcmp(tok->lexeme, "fn") == 0) tok->type = TK_FN;
            else if (strcmp(tok->lexeme, "let") == 0) tok->type = TK_LET;
            else if (strcmp(tok->lexeme, "if") == 0) tok->type = TK_IF;
            else if (strcmp(tok->lexeme, "else") == 0) tok->type = TK_ELSE;
            else if (strcmp(tok->lexeme, "return") == 0) tok->type = TK_RETURN;
            else if (strcmp(tok->lexeme, "sw") == 0) tok->type = TK_IMPORT;
            else if (strcmp(tok->lexeme, "as") == 0) tok->type = TK_IDENT; // Pour 'as string'
            else tok->type = TK_IDENT;
            
            token_count++;
            continue;
        }
        
        // Nombres
        if (isdigit(ch)) {
            int j = 0;
            while (i < len && isdigit(source[i])) {
                if (j < 255) tok->lexeme[j++] = source[i];
                i++; col++;
            }
            tok->lexeme[j] = '\0';
            tok->type = TK_INTLIT;
            tok->int_val = atoi(tok->lexeme);
            token_count++;
            continue;
        }
        
        // Cha√Ænes
        if (ch == '"') {
            int j = 0;
            i++; col++;
            while (i < len && source[i] != '"') {
                if (j < 255) tok->lexeme[j++] = source[i];
                i++; col++;
            }
            if (i < len && source[i] == '"') {
                i++; col++;
            }
            tok->lexeme[j] = '\0';
            tok->type = TK_STRLIT;
            token_count++;
            continue;
        }
        
        // Op√©rateurs
        switch (ch) {
            case '+': tok->type = TK_PLUS; break;
            case '-': tok->type = TK_MINUS; break;
            case '*': tok->type = TK_MULT; break;
            case '/': tok->type = TK_DIV; break;
            case '%': tok->type = TK_MOD; break;
            case '=': 
                if (i + 1 < len && source[i + 1] == '=') {
                    tok->type = TK_EQ;
                    i++; col++;
                    strcpy(tok->lexeme, "==");
                } else {
                    tok->type = TK_ASSIGN;
                }
                break;
            case '!':
                if (i + 1 < len && source[i + 1] == '=') {
                    tok->type = TK_NEQ;
                    i++; col++;
                    strcpy(tok->lexeme, "!=");
                } else {
                    tok->type = TK_NOT;
                }
                break;
            case '<':
                if (i + 1 < len && source[i + 1] == '=') {
                    tok->type = TK_LE;
                    i++; col++;
                    strcpy(tok->lexeme, "<=");
                } else {
                    tok->type = TK_LT;
                }
                break;
            case '>':
                if (i + 1 < len && source[i + 1] == '=') {
                    tok->type = TK_GE;
                    i++; col++;
                    strcpy(tok->lexeme, ">=");
                } else {
                    tok->type = TK_GT;
                }
                break;
            case '(': tok->type = TK_LPAREN; break;
            case ')': tok->type = TK_RPAREN; break;
            case '{': tok->type = TK_LBRACE; break;
            case '}': tok->type = TK_RBRACE; break;
            case ';': tok->type = TK_SEMICOLON; break;
            case ':': tok->type = TK_COLON; break;
            case ',': tok->type = TK_COMMA; break;
            case '.': tok->type = TK_DOT; break;
            default: tok->type = TK_ERROR; break;
        }
        
        if (strlen(tok->lexeme) == 0) {
            tok->lexeme[0] = ch;
            tok->lexeme[1] = '\0';
        }
        
        i++; col++;
        token_count++;
    }
    
    tokens[token_count].type = TK_EOF;
    tokens[token_count].lexeme[0] = '\0';
    
    return tokens;
}

// === G√âN√âRATION DE CODE AM√âLIOR√âE ===
void generate_c_code(Token* tokens, const char* output_filename, Variable* vars, int* var_count) {
    FILE* f = fopen(output_filename, "w");
    if (!f) return;
    
    fprintf(f, "/* G√©n√©r√© par SwiftVelox */\n");
    fprintf(f, "#include <stdio.h>\n");
    fprintf(f, "#include <stdlib.h>\n");
    fprintf(f, "#include <string.h>\n\n");
    
    fprintf(f, "void sv_print(const char* msg) { printf(\"%%s\\n\", msg); }\n");
    fprintf(f, "void sv_print_int(int n) { printf(\"%%d\\n\", n); }\n");
    fprintf(f, "char* int_to_str(int n) {\n");
    fprintf(f, "    static char buf[32];\n");
    fprintf(f, "    sprintf(buf, \"%%d\", n);\n");
    fprintf(f, "    return buf;\n");
    fprintf(f, "}\n");
    fprintf(f, "char* str_concat(const char* a, const char* b) {\n");
    fprintf(f, "    char* result = malloc(strlen(a) + strlen(b) + 1);\n");
    fprintf(f, "    strcpy(result, a);\n");
    fprintf(f, "    strcat(result, b);\n");
    fprintf(f, "    return result;\n");
    fprintf(f, "}\n\n");
    
    fprintf(f, "int main() {\n");
    
    int i = 0;
    char current_var[256] = "";
    int expecting_value = 0;
    int in_print = 0;
    char print_buffer[BUFFER_SIZE] = "";
    int buffer_pos = 0;
    
    while (tokens[i].type != TK_EOF) {
        Token tok = tokens[i];
        
        if (tok.type == TK_LET) {
            // D√©claration de variable
            i++;
            if (tokens[i].type == TK_IDENT) {
                strcpy(current_var, tokens[i].lexeme);
                strcpy(vars[*var_count].name, tokens[i].lexeme);
                vars[*var_count].type[0] = '\0';
                (*var_count)++;
                
                i++; // skip ident
                
                // Type annotation
                if (tokens[i].type == TK_COLON) {
                    i++; // skip :
                    if (tokens[i].type == TK_IDENT) {
                        strcpy(vars[*var_count-1].type, tokens[i].lexeme);
                        i++;
                    }
                }
                
                // Assignment
                if (tokens[i].type == TK_ASSIGN) {
                    i++; // skip =
                    expecting_value = 1;
                }
            }
        }
        else if (expecting_value) {
            // Valeur d'assignation
            if (tok.type == TK_INTLIT) {
                fprintf(f, "    int %s = %d;\n", current_var, tok.int_val);
            }
            else if (tok.type == TK_STRLIT) {
                fprintf(f, "    const char* %s = \"%s\";\n", current_var, tok.lexeme);
            }
            else if (tok.type == TK_IDENT) {
                // Variable existante
                fprintf(f, "    int %s = %s;\n", current_var, tok.lexeme);
            }
            expecting_value = 0;
        }
        else if (tok.type == TK_IDENT && strcmp(tok.lexeme, "swget") == 0) {
            in_print = 1;
            i += 2; // skip '('
        }
        else if (in_print && tok.type == TK_STRLIT) {
            if (buffer_pos > 0) {
                strcat(print_buffer, tok.lexeme);
            } else {
                strcpy(print_buffer, tok.lexeme);
            }
        }
        else if (in_print && tok.type == TK_IDENT) {
            // Variable dans swget
            if (buffer_pos == 0) {
                snprintf(print_buffer, BUFFER_SIZE, "\"%s\"", tok.lexeme);
            } else {
                char temp[BUFFER_SIZE];
                snprintf(temp, BUFFER_SIZE, "str_concat(%s, %s)", print_buffer, tok.lexeme);
                strcpy(print_buffer, temp);
            }
        }
        else if (in_print && tok.type == TK_PLUS) {
            // Concat√©nation
            i++;
            if (tokens[i].type == TK_IDENT && tokens[i+1].type == TK_IDENT && 
                strcmp(tokens[i+1].lexeme, "as") == 0) {
                // Conversion 'as string'
                i += 3; // skip variable, 'as', 'string'
                if (buffer_pos == 0) {
                    snprintf(print_buffer, BUFFER_SIZE, "int_to_str(%s)", tokens[i-3].lexeme);
                } else {
                    char temp[BUFFER_SIZE];
                    snprintf(temp, BUFFER_SIZE, "str_concat(%s, int_to_str(%s))", 
                            print_buffer, tokens[i-3].lexeme);
                    strcpy(print_buffer, temp);
                }
            }
        }
        else if (in_print && tok.type == TK_RPAREN) {
            // Fin de swget
            fprintf(f, "    sv_print(%s);\n", print_buffer);
            in_print = 0;
            print_buffer[0] = '\0';
            buffer_pos = 0;
        }
        else if (tok.type == TK_IF) {
            fprintf(f, "    if (");
            i++; // skip if
            
            // Condition
            while (tokens[i].type != TK_LBRACE && tokens[i].type != TK_EOF) {
                if (tokens[i].type == TK_IDENT) {
                    fprintf(f, "%s", tokens[i].lexeme);
                }
                else if (tokens[i].type == TK_INTLIT) {
                    fprintf(f, "%d", tokens[i].int_val);
                }
                else if (tokens[i].type == TK_GT) {
                    fprintf(f, " > ");
                }
                else if (tokens[i].type == TK_LT) {
                    fprintf(f, " < ");
                }
                else if (tokens[i].type == TK_EQ) {
                    fprintf(f, " == ");
                }
                i++;
            }
            fprintf(f, ") {\n");
        }
        else if (tok.type == TK_ELSE) {
            fprintf(f, "    } else {\n");
        }
        else if (tok.type == TK_LBRACE) {
            fprintf(f, "    {\n");
        }
        else if (tok.type == TK_RBRACE) {
            fprintf(f, "    }\n");
        }
        
        i++;
    }
    
    fprintf(f, "    return 0;\n");
    fprintf(f, "}\n");
    fclose(f);
}

// === COMPILATEUR PRINCIPAL ===
int compile_file(const char* input_file, const char* output_file) {
    printf("‚ö° Compilation: %s\n", input_file);
    
    FILE* f = fopen(input_file, "r");
    if (!f) {
        printf("‚ùå Fichier introuvable\n");
        return 0;
    }
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* source = malloc(size + 1);
    fread(source, 1, size, f);
    source[size] = '\0';
    fclose(f);
    
    Token* tokens = tokenize(source);
    
    Variable variables[MAX_SYMBOLS];
    int var_count = 0;
    
    char out_name[256];
    if (!output_file) {
        snprintf(out_name, sizeof(out_name), "%s.c", input_file);
        output_file = out_name;
    }
    
    generate_c_code(tokens, output_file, variables, &var_count);
    
    free(source);
    printf("‚úÖ Code C g√©n√©r√©: %s\n", output_file);
    return 1;
}

void compile_and_run(const char* filename) {
    char c_file[256];
    char exe_file[256];
    
    snprintf(c_file, sizeof(c_file), "%s.c", filename);
    snprintf(exe_file, sizeof(exe_file), "%s.out", filename);
    
    if (!compile_file(filename, c_file)) return;
    
    printf("üî® Compilation C...\n");
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "gcc -O2 -o %s %s 2>&1", exe_file, c_file);
    
    if (system(cmd) != 0) {
        printf("‚ùå Erreur compilation C\n");
        return;
    }
    
    printf("‚úÖ Ex√©cutable cr√©√©: %s\n", exe_file);
    
    printf("üöÄ Ex√©cution...\n\n");
    snprintf(cmd, sizeof(cmd), "./%s", exe_file);
    int result = system(cmd);
    
    if (result != 0) {
        printf("\n‚ö†Ô∏è  Code de sortie: %d\n", result);
    }
}

void print_help() {
    printf("SwiftVelox Compiler v2.0\n");
    printf("Usage: svc <commande> [fichier]\n");
    printf("Commandes:\n");
    printf("  build <fichier.svx>   Compile en C\n");
    printf("  run <fichier.svx>     Compile et ex√©cute\n");
    printf("  version               Affiche la version\n");
    printf("\nExemple:\n");
    printf("  svc run examples/calc.svx\n");
}

int main(int argc, char** argv) {
    if (argc < 2) {
        print_help();
        return 1;
    }
    
    char* cmd = argv[1];
    
    if (strcmp(cmd, "version") == 0) {
        printf("SwiftVelox v2.0 - Compilateur C am√©lior√©\n");
    }
    else if (strcmp(cmd, "build") == 0) {
        if (argc < 3) {
            printf("‚ùå Fichier .svx requis\n");
            return 1;
        }
        compile_file(argv[2], NULL);
    }
    else if (strcmp(cmd, "run") == 0) {
        if (argc < 3) {
            printf("‚ùå Fichier .svx requis\n");
            return 1;
        }
        compile_and_run(argv[2]);
    }
    else {
        // Si pas de commande, essayer de compiler directement
        compile_and_run(argv[1]);
    }
    
    return 0;
}
EOF

# Recompiler
make clean
make

# Cr√©er un meilleur exemple de calcul
cat > SwiftVelox/examples/calc_fixed.svx << 'EOF'
// Calculatrice avec affichage correct
fn main() {
    let a = 10
    let b = 20
    
    swget("Addition: " + (a + b) as string)
    swget("Soustraction: " + (a - b) as string)
    swget("Multiplication: " + (a * b) as string)
    
    if a > b {
        swget("a est plus grand")
    } else {
        swget("b est plus grand ou √©gal")
    }
}

fn test() {
    let x = 5
    let y = 3
    swget("Test: " + (x * y) as string)
}
EOF

# Tester
echo "=== TEST ==="
./svc run examples/calc_fixed.svx