#include "backend.h"
#include "common.h"
#include <stdio.h>
#include <string.h>

// Create LLVM backend context
BackendContext* backend_create(BackendTarget target, const char* filename) {
    BackendContext* context = ALLOC(BackendContext);
    CHECK_ALLOC(context, "Backend context allocation");
    
    context->target = target;
    context->output_filename = str_copy(filename);
    context->label_counter = 0;
    context->temp_counter = 0;
    context->symbol_table = NULL;
    
    if (filename) {
        if (str_endswith(filename, ".ll")) {
            context->output_file = fopen(filename, "w");
        } else {
            char* ll_filename = str_format("%s.ll", filename);
            context->output_file = fopen(ll_filename, "w");
            free(ll_filename);
        }
        
        if (!context->output_file) {
            LOG(LOG_ERROR, "Cannot open output file: %s", context->output_filename);
            free(context);
            return NULL;
        }
    }
    
    return context;
}

// Free backend context
void backend_free(BackendContext* context) {
    if (!context) return;
    
    if (context->output_file && context->output_file != stdout) {
        fclose(context->output_file);
    }
    
    FREE(context->output_filename);
    FREE(context);
}

// Generate unique label
char* llvm_generate_label(BackendContext* context, const char* prefix) {
    char* label = str_format("%s%d", prefix, context->label_counter++);
    return label;
}

// Generate unique temporary variable
char* llvm_generate_temp(BackendContext* context) {
    char* temp = str_format("%%t%d", context->temp_counter++);
    return temp;
}

// Emit LLVM prologue
void llvm_emit_prologue(BackendContext* context) {
    if (!context->output_file) return;
    
    fprintf(context->output_file, "; LLVM IR generated by SwiftFlow\n");
    fprintf(context->output_file, "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n");
    fprintf(context->output_file, "target triple = \"x86_64-pc-linux-gnu\"\n\n");
    
    // Declare external functions
    fprintf(context->output_file, "declare i32 @printf(i8*, ...)\n");
    fprintf(context->output_file, "declare i32 @scanf(i8*, ...)\n");
    fprintf(context->output_file, "declare i8* @malloc(i64)\n");
    fprintf(context->output_file, "declare void @free(i8*)\n");
    fprintf(context->output_file, "declare i32 @puts(i8*)\n\n");
    
    // String constant for printf
    fprintf(context->output_file, "@.int_fmt = private constant [4 x i8] c\"%%d\\0A\\00\"\n");
    fprintf(context->output_file, "@.float_fmt = private constant [4 x i8] c\"%%f\\0A\\00\"\n");
    fprintf(context->output_file, "@.str_fmt = private constant [4 x i8] c\"%%s\\0A\\00\"\n");
    fprintf(context->output_file, "@.bool_true = private constant [5 x i8] c\"true\\00\"\n");
    fprintf(context->output_file, "@.bool_false = private constant [6 x i8] c\"false\\00\"\n\n");
    
    // Start main function
    fprintf(context->output_file, "define i32 @main() {\n");
    fprintf(context->output_file, "entry:\n");
}

// Emit LLVM epilogue
void llvm_emit_epilogue(BackendContext* context) {
    if (!context->output_file) return;
    
    fprintf(context->output_file, "  ret i32 0\n");
    fprintf(context->output_file, "}\n");
}

// Emit integer constant
void llvm_emit_int(BackendContext* context, int64_t value) {
    char* temp = llvm_generate_temp(context);
    fprintf(context->output_file, "  %s = add i64 0, %ld\n", temp, value);
}

// Emit float constant
void llvm_emit_float(BackendContext* context, double value) {
    char* temp = llvm_generate_temp(context);
    fprintf(context->output_file, "  %s = fadd double 0.0, %f\n", temp, value);
}

// Emit string constant
void llvm_emit_string(BackendContext* context, const char* value) {
    // Create string constant
    char* str_const = llvm_generate_label(context, "@.str");
    fprintf(context->output_file, "%s = private constant [%lu x i8] c\"%s\\00\"\n", 
            str_const, strlen(value) + 1, value);
    
    // Get pointer to string
    char* temp = llvm_generate_temp(context);
    fprintf(context->output_file, "  %s = getelementptr [%lu x i8], [%lu x i8]* %s, i64 0, i64 0\n",
            temp, strlen(value) + 1, strlen(value) + 1, str_const);
    
    free(str_const);
    free(temp);
}

// Emit print statement
void llvm_emit_print(BackendContext* context, ASTNode* node) {
    if (!node->left) return;
    
    ASTNode* value = node->left;
    
    switch (value->type) {
        case NODE_INT:
            // Load integer value
            fprintf(context->output_file, "  %%print_val = add i64 0, %ld\n", value->data.int_val);
            fprintf(context->output_file, "  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.int_fmt, i64 0, i64 0), i64 %%print_val)\n");
            break;
            
        case NODE_FLOAT:
            // Load float value
            fprintf(context->output_file, "  %%print_val_f = fadd double 0.0, %f\n", value->data.float_val);
            fprintf(context->output_file, "  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.float_fmt, i64 0, i64 0), double %%print_val_f)\n");
            break;
            
        case NODE_STRING:
            // Create string constant
            llvm_emit_string(context, value->data.str_val);
            fprintf(context->output_file, "  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str_fmt, i64 0, i64 0), i8* %%t%d)\n", 
                    context->temp_counter - 1);
            break;
            
        case NODE_BOOL:
            // Boolean value
            if (value->data.bool_val) {
                fprintf(context->output_file, "  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str_fmt, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.bool_true, i64 0, i64 0))\n");
            } else {
                fprintf(context->output_file, "  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str_fmt, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.bool_false, i64 0, i64 0))\n");
            }
            break;
            
        default:
            LOG(LOG_WARNING, "Unsupported type for print: %s", 
                node_type_to_string(value->type));
            break;
    }
}

// Emit variable declaration
void llvm_emit_var_decl(BackendContext* context, ASTNode* node) {
    // Allocate space for variable
    char* var_name = node->data.name;
    fprintf(context->output_file, "  %%var_%s = alloca i64\n", var_name);
    
    // Initialize if provided
    if (node->left) {
        ASTNode* init_value = node->left;
        
        if (init_value->type == NODE_INT) {
            fprintf(context->output_file, "  store i64 %ld, i64* %%var_%s\n", 
                    init_value->data.int_val, var_name);
        } else {
            LOG(LOG_WARNING, "Unsupported initializer type for variable: %s", 
                node_type_to_string(init_value->type));
        }
    }
}

// Emit binary operation
void llvm_emit_binary(BackendContext* context, ASTNode* node) {
    // TODO: Implement binary operation code generation
    // This is a simplified version
    
    char* temp_result = llvm_generate_temp(context);
    
    // For now, just handle integer addition
    if (node->op_type == TK_PLUS && 
        node->left && node->left->type == NODE_INT &&
        node->right && node->right->type == NODE_INT) {
        
        fprintf(context->output_file, "  %s = add i64 %ld, %ld\n",
                temp_result, node->left->data.int_val, node->right->data.int_val);
    }
    
    free(temp_result);
}

// Emit AST node recursively
void llvm_emit_node(BackendContext* context, ASTNode* node) {
    if (!node) return;
    
    switch (node->type) {
        case NODE_PRINT:
            llvm_emit_print(context, node);
            break;
            
        case NODE_VAR_DECL:
        case NODE_NET_DECL:
        case NODE_CLOG_DECL:
        case NODE_DOS_DECL:
        case NODE_SEL_DECL:
        case NODE_CONST_DECL:
        case NODE_GLOBAL_DECL:
            llvm_emit_var_decl(context, node);
            break;
            
        case NODE_BINARY:
            llvm_emit_binary(context, node);
            break;
            
        case NODE_BLOCK:
            // Emit all statements in block
            ASTNode* stmt = node->left;
            while (stmt) {
                llvm_emit_node(context, stmt);
                stmt = stmt->right;
            }
            break;
            
        case NODE_PROGRAM:
            // Emit all top-level statements
            ASTNode* top_stmt = node->left;
            while (top_stmt) {
                llvm_emit_node(context, top_stmt);
                top_stmt = top_stmt->right;
            }
            break;
            
        default:
            LOG(LOG_WARNING, "Unsupported node type for LLVM backend: %s", 
                node_type_to_string(node->type));
            break;
    }
}

// Compile AST to LLVM IR
void llvm_compile(BackendContext* context, ASTNode* ast) {
    LOG(LOG_INFO, "Generating LLVM IR...");
    
    llvm_emit_prologue(context);
    llvm_emit_node(context, ast);
    llvm_emit_epilogue(context);
    
    LOG(LOG_INFO, "LLVM IR generation complete");
}
