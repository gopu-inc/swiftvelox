// modules/core/math.swf - Version corrigÃ©e

// Constantes
var PI = 3.141592653589793;
var E = 2.718281828459045;

// Valeur NaN pour les erreurs
var NAN = 0.0 / 0.0;

// Fonction valeur absolue
func abs(x) {
    if (x < 0) {
        return -x;
    }
    return x;
}

// Fonction racine carrÃ©e (mÃ©thode de Newton)
func sqrt(x) {
    if (x < 0) {
        return NAN; // Retourne NaN pour les nombres nÃ©gatifs
    }
    
    if (x == 0) {
        return 0;
    }
    
    var guess = x / 2.0;
    var i = 0;
    
    while (i < 20) {
        guess = (guess + x / guess) / 2.0;
        i = i + 1;
    }
    
    return guess;
}

// Fonction puissance
func pow(base, exponent) {
    if (exponent == 0) {
        return 1;
    }
    
    var result = 1.0;
    var i = 0;
    
    // Utiliser abs pour gÃ©rer les exposants nÃ©gatifs
    var abs_exp = exponent;
    if (exponent < 0) {
        abs_exp = -exponent;
    }
    
    while (i < abs_exp) {
        result = result * base;
        i = i + 1;
    }
    
    if (exponent < 0) {
        return 1.0 / result;
    }
    
    return result;
}

// Minimum de deux nombres
func min(a, b) {
    if (a < b) {
        return a;
    }
    return b;
}

// Maximum de deux nombres
func max(a, b) {
    if (a > b) {
        return a;
    }
    return b;
}

// Arrondi Ã  l'infÃ©rieur
func floor(x) {
    if (x >= 0) {
        return int(x);
    } else {
        var int_val = int(x);
        if (x == int_val) {
            return int_val;
        }
        return int_val - 1;
    }
}

// Arrondi au supÃ©rieur
func ceil(x) {
    if (x <= 0) {
        return int(x);
    } else {
        var int_val = int(x);
        if (x == int_val) {
            return int_val;
        }
        return int_val + 1;
    }
}

// Arrondi classique
func round(x) {
    if (x >= 0) {
        return int(x + 0.5);
    } else {
        return int(x - 0.5);
    }
}

// Restriction entre min et max
func clamp(value, min_val, max_val) {
    if (value < min_val) {
        return min_val;
    }
    if (value > max_val) {
        return max_val;
    }
    return value;
}

// Interpolation linÃ©aire
func lerp(a, b, t) {
    return a + (b - a) * t;
}

// Fonction pour tester le module (nom diffÃ©rent de 'main')
func test_math() {
    print("ðŸ§® Testing Math Module...");
    print("");
    
    print("Constants:");
    print("  PI = " + PI);
    print("  E = " + E);
    print("");
    
    print("Absolute value:");
    print("  abs(-5) = " + abs(-5));
    print("  abs(5) = " + abs(5));
    print("  abs(0) = " + abs(0));
    print("");
    
    print("Square root:");
    print("  sqrt(16) = " + sqrt(16));
    print("  sqrt(9) = " + sqrt(9));
    print("  sqrt(2) â‰ˆ " + sqrt(2));
    print("  sqrt(-1) = " + sqrt(-1) + " (should be NaN)");
    print("");
    
    print("Power:");
    print("  pow(2, 3) = " + pow(2, 3));
    print("  pow(5, 0) = " + pow(5, 0));
    print("  pow(2, -1) = " + pow(2, -1));
    print("");
    
    print("Min/Max:");
    print("  min(10, 20) = " + min(10, 20));
    print("  max(10, 20) = " + max(10, 20));
    print("");
    
    print("Rounding:");
    print("  floor(3.7) = " + floor(3.7));
    print("  floor(-3.7) = " + floor(-3.7));
    print("  ceil(3.2) = " + ceil(3.2));
    print("  ceil(-3.2) = " + ceil(-3.2));
    print("  round(3.5) = " + round(3.5));
    print("  round(3.4) = " + round(3.4));
    print("");
    
    print("Clamp/Lerp:");
    print("  clamp(15, 0, 10) = " + clamp(15, 0, 10));
    print("  clamp(-5, 0, 10) = " + clamp(-5, 0, 10));
    print("  clamp(5, 0, 10) = " + clamp(5, 0, 10));
    print("  lerp(0, 10, 0.5) = " + lerp(0, 10, 0.5));
    print("");
    
    print("âœ… Math Module Test Completed Successfully!");
}

